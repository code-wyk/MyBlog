[TOC]



# 面试题总结

## JAVA

### 1. Java基础

#### JDK和JRE有什么区别

1. JDK：Java开发工具包(Java Development Kit)，提供了Java的开发环境和运行环境=JRE+JVM
2. JRE：Java运行环境(Java Runtime Environment)，提供了Java运行所需的环境

#### java语言具有哪些特点

1. Java为纯面向对象语言。在java世界中万物皆对象
2. 具有平台无关性。java利用java虚拟机运行字节码，生成class文件，无论是在Windows、Linux还是MacOS等其他平台对Java程序进行编译，编译后的程序可在其他平台运行
3. Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制，去除了C++中难以理解的指针特性
4. Java语言提供了对Web应用开发的支持，spring全家桶

#### 面向对象的三大特性

1. 继承：一个新类可以从现有的类中派生，派生类可以从它的基类继承方法和实例变量，并根据应用场景去修改和增加。
2. 封装：将客观事物抽象成类，自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏
3. 多态：允许不同子类型的对象对同一消息作出不同的响应。分为编译时多态和运行时多态，编译时多态就是方法重载，运行时多态就是方法重写，让父类型引用引用子类型对象，这样同样的引用调用同样的方法会根据子类对象的不同而表现出不同的行为

#### 访问修饰符public，private，protected以及不写时候default的区别

private是只有当前类可以访问，default是只有同包的类可以访问，而protected是同包的类和不同包的子类可以访问，public就是所有域都可以访问

#### 简述java的多态机制

java提供了两种用于多态的机制，分别是重载和覆盖，重载是静态多态，在编译前就会确定调用哪个方法，而覆盖是动态多态，在运行时候才会确定

1. 重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法
2. 覆盖：覆盖是指派生类重写基类的方法，使用基类指向子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法

#### 重载与覆盖的区别

1. 覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系
2. 覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系
3. 覆盖要求参数列表相同；重载要求参数列表不同
4. 覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体
5. 重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型

#### 构造方法是否可以被重写

构造器不能被继承，因为每个类的类名都不相同。由于构造器不能被继承，所以就不能被重写。但是子类构造函数中默认有super()，在创建子类的时候，会自动调用父类构造函数

#### final关键字

**变量**：对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其再指向另一个对象

**方法**：方法锁定，防止任何继承类修改它的含义；效率高，早期的java版本会将final方法指定为内嵌调用。类中的任何private方法都被隐式地指定为final

**类**：限定继承。当用final来修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法

####  final、finally和finalize的区别

1. final属于声明属性、方法和类，分别表示属性不可变，方法不可覆盖，类不可继承
2. finally作为异常处理的一部分，只能在try/catch语句中使用，finally附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下
3. finalize是Object类中的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存

#### 出现在Java程序中的finally代码块是否一定会执行

当遇到下面情况不会执行：

1. 当程序在进入try语句块之前就出现异常时会直接结束
2. 当程序在try块中强制退出时，如使用System.exit()，也不会执行finally()中的代码

其他情况下，在try/catch/finally语句执行的时候，try块先执行，当有异常发生，catch和finally进行处理后程序就结束了，当没有异常发生，在执行完finally中的代码后，后面的代码会继续执行。值得注意的是，当try/catch语句块中有return时，finally语句块中的代码会在return之前执行。如果try/catch/finally块中都有return语句，finally块中的return语句会覆盖try/catch模块中的return语句

#### 字节序定义以及java属于那种字节序

字节序是指多字节数据在计算机内存中存储或网络传输时字节的存储顺序。通常有小端和大端两种方式。

1. 小端：低位字节存放在内存的低位地址端，高位字节存放在内存的高地址端
2. 大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端

#### 简述java访问修饰符

* default：默认访问修饰符，在同一包内可见
* private：在同一类内可见，不能修饰类
* protected：对同一包内的类和所有子类可见，不能修饰类
* public：对所有类可见

#### 接口和抽象类的相同点和区别

相同点：

1. 都不能被实例化
2. 接口的实现类或抽象类的子类需实现接口或抽象类中响应的方法

不同点：

1. 接口只能有方法的定义，不能有方法的实现，而抽象类可以有方法的定义与实现
2. 实现接口的关键字为implements，继承抽象类的关键字为extends
3. 一个类可以实现多个接口，只能继承一个抽象类
4. 当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加方法

#### 接口和抽象类的区别是什么

* 接口的方法默认是public，所有方法在接口中不能有实现(java8开始接口方法可以有默认实现)，抽象类可以有非抽象的方法
* 接口中的实例变量默认是final类型的，而抽象类的则不一定
* 一个类可以实现多个接口，但最多只能实现一个抽象类
* 一个类实现接口的话要实现接口的所有方法，而抽象类不一定
* 接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象，从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范

#### 为什么java语言不支持多继承

1. 为了程序的结构能够更加清晰从而便于维护。假设java语言支持多重继承，类C继承自类A和类B，如果类A和B都有自定义的成员方法，那么当代码中调用C的f()会产生二义性。java语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类C继承接口A与接口B时即使它们都有方法，也不能直接调用方法，需实现具体的f()方法才能调用，不会产生二义性
2. 多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响性能

#### java中==和equals的区别

https://blog.csdn.net/qq_46804966/article/details/114783014?utm_medium=distribute.pc_category.none-task-blog-hot-14.nonecase&dist_request_id=&depth_1-utm_source=distribute.pc_category.none-task-blog-hot-14.nonecase

[(22条消息) java中的栈、堆以及equals和==的区别_yinzhijiezhan的专栏-CSDN博客](https://blog.csdn.net/yinzhijiezhan/article/details/44221577)

**==**：

* ==是比较运算符，对于基本数据类型来说，如果进行比较的两个操作数相同，即使数据类型不同，只要他们的值相等，也都将返回true.
* 对于引用数据类型来说，比较的是引用所指向的对象，即比较两个对象的地址是否相同，如果相同，返回true，否则返回false；比较的是引用对象在栈中存放的值，而栈中存放的值指向堆中的对象，即比较的是两个引用变量指向的是不是同一个地址的对象

**equals()**:

* equals()方法是Object类的方法，在Object类中的equals()方法体内实际上返回的就是使用==进行比较的结果
* 我们所知道的类都是继承自Object类的，Object类中的equals()方法没有使用final关键字修饰，当我们使用equals方法进行比较的时候，我们需要关注的是这个类有没有重写Object中的equals()方法

#### ==和===的区别

===：称为等同符，当两边值的类型相同时，直接比较值，若类型不相同，直接返回false；

==：称为等值符，当等号两边的类型相同时，直接比较值是否相等，若不相同，则先转化为类型相同的值，再进行比较；

#### 什么是自动装箱，自动拆箱

**定义**：基本数据类型和包装器类型可以自动地相互转换。装箱就是自动将基本数据类型转换为封装类型，拆箱就是自动将封装类型转换为基本数据类型

| 数据类型 | 封装类    |
| -------- | --------- |
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| char     | Character |
| boolean  | Boolean   |

![image-20210324152059123](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210324152059123.png)

**理解**：日常的开发基本数据类型几乎可以满足我们的需求，但是基本类型终究不是对象，往重了说不满足java面向对象的开发思想，将基本数据类型进行装箱可以便捷地使用封装在包装器类中的方法，使开发更加便捷

```java
//自动装箱
Integer a=100；
//自动拆箱
int b=a;
```

自动装箱：相当于java编译器替我们执行了Integer.valueOf(xxx)

自动拆箱：相当于java编译器替我们执行了Integer.intValue(xxx)

#### 获取用键盘输入常用的两种方法

**1.通过Scanner**:

```java
Scanner input=new Scanner(System.in);
String s=input.nextLine();
input.close();
```

**2.通过BufferedReader**:

```java
BufferedReader input=new BufferedReader(new InputStreamReader(System.in))
String s=input.readLine();
```

#### Java语言中关键字static的作用是什么

static的主要作用有两个：

1. 为某种特定数据类型或对象分配与创建对象个数无关的单一存储空间
2. 使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性

具体而言static又可分为4种使用方式：

1. 修饰成员变量。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用"类.静态变量"或"对象.静态变量"的方法使用
2. 修饰成员方法。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法
3. 修饰代码块。JVM在加载类的时候会执行static代码块，static代码块常用于初始化静态变量，static代码块只会被执行一次
4. 修饰内部类。static内部类可以不依赖外部实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法

#### String、StringBuffer和StringBuilder有什么区别

String用于字符串操作，属于不可变类，利用final修饰的字符数组进行保存，String对象一旦被创建，其值将不能被改变，如果对String类型对象修改，需要新建对象，将老字符和新增加字符一并保存进去。StringBuilder采用无final修饰的字符串数组进行保存，但线程不安全。StringBuffer可理解为线程安全的StringBuilder

#### 为什么要把String设计为不可变量

1. 节省空间：字符串常量存储在JVM的字符串池中可以被用户共享
2. 提高效率：String会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作
3. 安全：String常用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改

#### 序列化是什么

序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个对象。

具体实现：实现Serializable接口，或实现Externalizable接口中的writeExternal()与readExternal()方法

#### Java反射机制是什么

Java反射机制是指在程序运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。反射机制使得Java具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射API:

* Class类：可获得类属性方法
* Field类：获得类的成员变量
* Method类：获取类的方法信息
* Construct类：获取类的构造方法等信息

#### 简述Java中的Class对象

java中对象可以分为实例对象和Class对象，每一个类都有一个Class对象，其包含了与该类有关的信息。

获取Class对象的方法：

* Class.forName("类的全限定名")
* 实例对象.getClass()
* 类名.class

#### 简述注解

Java注解用于为Java代码提供元数据。作为元数据，注解并不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理相应代码，做对应操作

#### 简述元注解

元注解可以理解为注解的注解，即在注解中使用，实现想要的功能，其具体分为：

* @Retention:表示注解存在阶段是保留在源码
* @Target:表示注解作用的范围
* @Documented:表示注解作用的范围
* @Documented:将注解中的元素包含到Javadoc中去
* @Inherited:一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解
* @Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义

#### 简述Java异常的分类

Java异常分为Error(程序无法处理的错误)和Exception(程序本身可以处理的异常)。这两个类均继承Throwable。Error常见的有StackOverFlowError，OutOfMemoryError等等。Exception可分为运行时异常和非运行时异常。对于运行时异常，可以利用try catch的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。

#### 简述throw和throws的区别

throw一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常，抛出一个具体的异常类型，由方法体内的语句处理

throws一般用于方法声明上，代表该方法可能会抛出的异常列表，用来声明一个方法可能产生的异常，不做任何处理而是将异常向上传递，谁调用就传给谁

#### 简述泛型

泛型，即"参数化类型"，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类，接口中称为泛型接口和方法中称为泛型方法

#### 简述泛型擦除

Java的泛型基本上都是在编译器这个层次上实现的，编译器生成的字节码是不包含泛型信息的，Java的泛型是伪泛型，在编译期间，所有的泛型信息都会被擦掉

#### 简述Object类常用方法

1. hashCode：通过对象计算出的散列码，用于map型或equals方法，需要保证同一个对象多次调用该方法，总返回包含的整型值
2. equals：判断两个对象是否一致。需保证equals方法相同时候对应的对象的hashCode也相同
3. toString：用字符串表示该对象
4. clone：深拷贝一个对象

#### Java浅拷贝和深拷贝

浅拷贝：被拷贝对象和拷贝对象指向的都是同一个地址，任何一个对象的改变都会引起另一个对象的改变；即浅拷贝拷贝的是对象的地址

深拷贝：被拷贝对象和拷贝对象，两个对象指向不同的地址，真正地生成一个对象。常见的几种拷贝范式：

* 构造函数方式
* 重写clone方法
* Apache Commons Lang序列化
* Gson序列化
* Jaskson序列化

#### 简述内部类及其作用

* 成员内部类：作为成员对象的内部类。可以访问private及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问private修饰的内部类属性
* 局部内部类：存在于方法中的内部类。访问权限类似局部变量，智能访问外部类的final变量
* 匿名内部类：只能使用一次，没有类名，只能访问外部类的final变量
* 静态内部类：类似于类的静态成员变量

#### 简述Java中的List

List是一个有序队列，在java中有两种实现方式：

* ArrayList使用数组实现，是容量可变的非线程安全列表，随机访问块，集合扩容时会创建更大的数组，把原有的数组复制到新数组
* LinkedList本质是双向链表，与ArrayList相比插入和删除速度更快，但随机访问元素很慢

#### 简述Java中的Set

Set即集合，该数据结构不允许元素重复且无序。java对Set有三种实现方式：

* HashSet通过HashMap实现，HashMap的Key即HashSet存储的元素，Value系统自定义一个名为PRESENT的Object类型常量。判断元素是否相同时，先比较hashCode，相同后再利用equals比较，查询O(1)
* LinkedHashSet继承自HashSet，通过LinkedHashMap实现，使用双向链表维护元素插入顺序
* TreeSet通过TreeMap实现，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序，查询O(logn)

#### 简述Java中的HashMap

JDK8之前底层是数组+链表，JDK8之后改为数组+链表/红黑树。主要成员变量包括存储数据的table数组，元素数量size，加载因子loadFactor。HashMap中数据以键值对的形式存在，键对应的hash值用来计算数组下标，如果两个元素key的hash值一样，就会发生哈希冲突，被放到同一个链表上。table数组记录HashMap的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry结点包含四个成员变量：key、value、next指针和hash值。在JDK8后链表超过8会转化为红黑树。若当前数据/总数据容量>负载因子，HashMap将执行扩容操作。默认初始化容量为16，扩容容量必须是2的幂次方，最大容量为2<sup>30</sup>，默认加载因子为0.75

#### HashMap在JDK1.8之后为什么要变为红黑树



#### 简述Java中的TreeMap

TreeMap是底层利用红黑树实现的Map结构，底层实现是一颗平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为O(logn)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出

#### ArrayList、Vector和LinkedList有什么共同点与区别

1. ArrayList、Vector和LinkedList都是可伸缩的数组，即可以动态改变长度的数组
2. ArrayList和Vector都是基于存储元素的Object[] array来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。当存储元素超过容器的初始化容量大小，ArrayList与Vector均会进行扩容
3. Vector是线程安全的，其大部分方法是直接或间接同步的。ArrayList不是线程安全的，其方法不具有同步性质。LinkedList也不是线程安全的
4. LinkedList采用双向链表实现，对数据索引需要从头开始遍历，因此随机访问效率极低，但在插入元素的时候不需要对数据进行移动，插入效率较高

#### HashMap和HashTable有什么区别

1. HashMap是HashTable的轻量级实现，HashMap允许key和value为null，但最多允许一条记录的key为null，而HashTabe不允许
2. HashTable中的方法是线程安全的，而HashMap不是。在多线程访问HashMap需要提供额外的同步机制
3. HashTable使用Enumeration进行遍历，HashTable使用Iterator进行遍历

#### 如何决定使用HashMap还是TreeMap

如果对Map进行插入、删除或定位一个元素的操作更频繁，HashMap是更好的选择。如果需要对key集合进行有序的遍历，TreeMap是更好的选择

#### fail-fast和fail-safe迭代器的区别是什么

1. fail-fast直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻爆出ConcurrentModificationException异常从而导致遍历失败。常见的fail-fast方式的容器有HashMap和ArrayList等
2. fail-safe这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用fail-safe方式遍历的容器有ConcurrentHashMap和CopyOnWriteArrayList

#### HashSet中，equals和hashCode之间的关系

equals和hashCode这两个方法都是从Object类中继承过来的。equals主要用于判断对象的内存地址引用是否是同一个地址；hashCode根据定义的哈希规则将对象的内存地址转换为一个哈希码。HashSet中存储的元素是不能重复的，主要通过hashCode与equals两个方法来判断存储的对象是否相同

1. 如果两个对象的hashCode值不同，说明两个对象不相同
2. 如果两个对象的hashCode值相同，接着会调用对象的equals方法，如果equals方法的返回结果为true，那么说明两个对象相同，否则不相同

#### java中线程安全的基本数据结构有哪些

* HashTable：哈希表的线程安全版，效率低
* ConcurrentHashMap：哈希表的线程安全版，效率低，用于替代HashTable
* Vector：线程安全版的ArrayList
* Stack：线程安全版栈
* BlockingQueue及其子类：线程安全版队列

###  2. java虚拟机

[(23条消息) 深入浅出JVM调优，看完你就懂_Javazhoumou的博客-CSDN博客_jvm调优](https://blog.csdn.net/Javazhoumou/article/details/99298624?ops_request_misc=%7B%22request%5Fid%22%3A%22162479450016780271551594%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fnavwordall.%22%7D&request_id=162479450016780271551594&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~navwordall~first_rank_v2~hot_rank-6-99298624.first_rank_v2_pc_rank_v29&utm_term=JVM&spm=1018.2226.3001.4187)

[(23条消息) 常见JVM面试题及答案整理_Java笔记-CSDN博客_jvm面试题](https://blog.csdn.net/qq_41701956/article/details/100074023?ops_request_misc=%7B%22request%5Fid%22%3A%22162479450016780271551594%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fnavwordall.%22%7D&request_id=162479450016780271551594&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~navwordall~first_rank_v2~hot_rank-1-100074023.first_rank_v2_pc_rank_v29&utm_term=JVM&spm=1018.2226.3001.4187)

#### 简述java内存模型(JMM)

java内存模型定义了程序中各种变量的访问规则。其规定所有变量都存储在主内存，线程均有自己的工作内存。工作内存中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回内存

#### 简述as-if-serial

#### 简述java中volatile关键字的作用

1. 保证变量对所有线程的可见性。当一条线程修改了变量值，新值对于其他线程来说是可以立即得知的
2. 禁止指令重排序优化。使用volatile变量进行写操作，汇编指令带有lock前缀，相当于一个内存屏障，编译器不会将后面的指令重排到内存屏障之前

### 3. Java多线程

#### 并行和并发的区别

并发：单核CPU执行多个线程，线程轮流执行CPU，时间片快速的切换

并行：多核CPU运行多线程，真正的在同一时刻运行

#### Thread和Runnable的区别

实现Runnable接口比继承Thread所具有的优势：

* 适合多个相同的程序代码的线程去处理同一个资源
* 可以避免java中单继承的限制
* 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
* 线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类

#### java中实现多线程的方式

* 继承Thread类
* 实现Runnable接口:将实现类以参数的形式传递到Thread对象的创建过程中
* 实现Callable接口

#### 简述java线程的状态

线程状态有：NEW,RUNNABLE,BLOCK,WAITING,TIMEED_WAITING,THERMINATED

* NEW：新建状态，线程被创建且未启动，此时还未调用start方法
* RUNNABLE：运行状态。其表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU
* BLOCKED：阻塞状态。线程等待获取锁，锁还没获得
* WAITING：等待状态。线程内run方法运行完语句Object.wait()/Thread.join()进入该状态
* TIMED_WAITING：期限等待。在一定时间之后跳出状态。调用Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间
* TERMINATED：结束状态。线程调用完run方法进入该状态

#### 简述线程通信的方式

1. volatile关键词修饰变量，保证所有线程对变量访问的可见性
2. synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中
3. wait/notify方法
4. IO通信

#### 简述线程池

没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后执行接下来任务，复用已创建的线程，降低开销、控制最大并发数。线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。将任务派发给线程池时，会出现以下几种情况

1. 核心线程池未满，创建一个新的线程执行任务。
2. 如果核心线程池已满，工作队列未满，将线程存储在工作队列。

3. 如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。
4. 如果超过大小线程数，按照拒绝策略来处理任务。

#### 线程池参数

1. corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。
2. maximumPoolSize：线程池能够容纳同时执行的线程最大数。
3. keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个
   线程为止，避免浪费内存资源。
4. workQueue：工作队列。
5. threadFactory：线程工厂，用来生产一组相同任务的线程。
6. handler：拒绝策略。有以下几种拒绝策略：

  * AbortPolicy：丢弃任务并抛出异常
  * CallerRunsPolicy： 重新尝试提交该任务
  * DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列
  * DiscardPolicy 表示直接抛弃当前任务但不抛出异常。

#### 线程池创建方法

1. newFixedThreadPool，创建固定大小的线程池。
2. newSingleThreadExecutor，使用单线程线程池。
3. newCachedThreadPool，maximumPoolSize 设置为 Integer 最大值，工作完成后会回收工作线程
4. newScheduledThreadPool：支持定期及周期性任务执行，不回收工作线程。
5. newWorkStealingPool：一个拥有多个任务队列的线程池。













### Java框架



## 数据结构与算法

## 计算机网络



### 网络协议是什么

计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式等。这些规则被称为网络协议。

### 为什么要对网络协议分层

* 简化问题和复杂度。各层之间独立，可以分割大问题为小问题

* 灵活性好。当其中一层的技术变化时，只要层间的接口关系保持不变，其他层不受影响

* 易于维护和实现

* 促进标准化工作。分开后，每层功能可以相对简单地被描述

  

![image-20210319210849620](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210319210849620.png)

五层协议的体系结构是为了介绍网络原理而设计的，实际应用的还是TCP/IP四层体系结构

### 简述OSI七层协议

OSI七层协议包括：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

数据链路层：提供介质访问和链路管理

网络层：IP选址及路由选择

传输层：建立、管理和维护端到端的连接

会话层：建立、管理和维护会话

表示层：数据格式转化、数据加密

应用层：为应用程序提供服务

### 简述TCP/IP五层协议

TCP/IP五层协议包括：物理层，数据链路层，网络层，传输层，应用层

### TCP三次握手过程

1. 第一次握手：客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端进入syn_sent状态，等待服务端确认
2. 第二次握手：服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态
3. 第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输数据了

### 为什么TCP握手需要三次，两次行不行？

不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号
起始值， 并确认对方已经收到了序列号起始值。
如果只是两次握手， 至多只有客户端的起始序列号能被确认， 服务器端的序列号则得不到确认。

### TCP四次挥手过程

1. 第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。
2. 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
3. 第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。
4. 第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。客户端在经过一段时间后自动进入Closed状态，至此客户端也完成连接的关闭

### 为什么挥手需要四次

关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次

### HTTP和HTTPS的区别




## 操作系统基础

### 进程与线程的区别

进程：每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大开销，一个进程包含1-n个线程；进程是资源分配的最小单位

线程：同一类线程共享代码和数据空间，每个线程都有独立的运行栈和程序计数器，线程切换开销小；线程是CPU调度的最小单位

线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止

多进程是指操作系统能够同时运行多个任务；多线程是指在同一程序中有多个顺序流在执行

### 什么是死锁

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进

### 如何避免死锁

银行家算法

## 数据库

[(23条消息) MySQL数据库面试题（2020最新版）_ThinkWon的博客-CSDN博客_mysql数据库面试题](https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%7B%22request%5Fid%22%3A%22162485574316780264082818%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=162485574316780264082818&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-104778621.first_rank_v2_pc_rank_v29&utm_term=数据库索引&spm=1018.2226.3001.4187)

[(23条消息) 数据库基本知识点总结_liuxyen的博客-CSDN博客_数据库知识点](https://blog.csdn.net/liuxyen/article/details/78591722?ops_request_misc=%7B%22request%5Fid%22%3A%22162483718716780262559797%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=162483718716780262559797&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78591722.first_rank_v2_pc_rank_v29&utm_term=数据库&spm=1018.2226.3001.4187)

[(23条消息) 数据库优化 - SQL优化_飘渺Jam的博客-CSDN博客_sql优化](https://blog.csdn.net/jianzhang11/article/details/102867120?ops_request_misc=%7B%22request%5Fid%22%3A%22162485477816780274177333%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fnavwordall.%22%7D&request_id=162485477816780274177333&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~navwordall~first_rank_v2~hot_rank-1-102867120.first_rank_v2_pc_rank_v29&utm_term=数据库&spm=1018.2226.3001.4187)

### 事务的概念和ACID

### 事务的应用场景

### 如何优化数据库

### InnoDB底层的数据结构？为什么

### 简单说一下Redis，它和Mysql的区别，以及各自的应用场景





## Linux



## 反问技巧

为了更好地胜任这个岗位，我还需要补充哪些技能？

入职后是否有产品培训和技能培训？

这个职位在公司的发展前景是怎样的？有什么晋升机制？在什么条件下，可以获得晋升机会？

赢得这个岗位需要几轮面试？接下来的流程是什么？

团队成员有多少人？大家怎么分工？目前团队的核心工作是哪些？

如果我来到公司之后，每天的日常工作是什么？

公司对我这个职位的期望是什么？

如何评估员工在试用期间的表现？考核标准是什么？

薪资结构，底薪是否与业绩挂钩

试用期多久，带不带薪培训

是否购买五险一金

上班时间，休息时间

岗位主要职责，其岗位人力组织架构是怎样

如果加班是否有补贴，如何计算加班费

晋升空间

如何转正 

公司对员工有什么硬性要求没

完！
